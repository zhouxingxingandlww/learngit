# 目录

| Chapter 1 | Chapter 2 | Chapter 3 |
| :---------: | :---------: | :-------:|
|[Tencent](#t)|[NetEase](#n)|[360](360)|

## <span id = "t">Tencent</span>

### 模拟1

Q1 :

    题目：
        随着IP网络的发展，为了节省可分配的注册IP地址，有一些地址被拿出来用于私有IP地址，以下不属于私有IP地址范围的是：
        A. 10.6.207.84
        B. 172.23.30.28
        C. 172.32.50.80
        D. 192.168.1.100

    答案：
        C

    解答：
        1. 私有IP地址共有三个范围段：
            A: 10.0.0.0~10.255.255.255，即10.0.0.0/8。
            B: 172.16.0.0~172.31.255.255，即172.16.0.0/12。
            C: 192.168.0.0~192.168.255.255，即192.168.0.0/16。
        2. 私有IP在公网上不能使用，但在内网内可以通过NAT技术分配给具体设备，节省IP地址。

Q2 :

    题目：
        下列关于一个类的静态成员的描述中，不正确的是：
        A. 该类的对象共享其静态成员变量的值
        B. 静态成员变量可被该类的所有方法访问
        C. 该类的静态方法能访问该类的静态成员变量
        D. 该类的静态数据成员变量的值不可修改

    答案：
        D

    解答：
        1. 类的静态成员和对象无关，和类相关，一个类的所有实例共享同一个静态成员。
        2. 静态成员函数不能调用非静态成员。
        3. 非静态成员函数可以调用静态成员。
        4. 静态成员变量必须初始化，且可以修改。

Q3 :

    题目：
        C++将父类的析构函数定义为虚函数，下列正确的是哪个：
        A. 释放父类指针时能正确释放子类对象
        B. 释放子类指针时能正确释放父类对象
        C. 这样做是错误的
        D. 以上全错

    答案：
        A

    解答：
        1. 基类通常应定义一个虚析构函数，以确保能正确执行析构函数。
        2. 基类指针指向派生类对象，若基类析构函数未声明为虚函数，则只会调用基类析构函数。
        3. 基类声明为虚函数，释放指向派生类对象的基类指针时会先调用派生类析构函数，之后调用基类析构函数。

Q4 :

    题目：
        下列哪一个不属于关系数据库的特点：
        A. 数据冗余度小
        B. 数据独立性高
        C. 数据共享性好
        D. 多用户访问

    答案：
        D

    解答：
        1. 数据库存在的一个目的就是统一管理数据，减少数据冗余度。
        2. 数据独立性，指数据和其管理软件独立，以及数据及其结构的独立。
        3. 数据库就是为了方便用户之间共享数据。
        4. 数据库中存在锁机制，如果多用户访问可能导致数据不一致等。

Q5 :

    题目：
        typedef char *String_t和#define String_d char *这两句在使用上有什么区别？

    答案：
        1. typedef char *String_t定义了一个新的类型别名，有类型检查，更安全。发生在编译阶段。
        2. #define String_d char *仅仅是做字符串替换，无类型检查。发生在预编译阶段。
        3. 用法区别：String_t a, b;
                    String_d c, d; -> char *c, d;
                    a, b ,c是char*类型，而d为char类型。

Q6 :

    题目：
        void Func(char str_arg[2]){
            int m = sizeof(str_arg);
            int n = strlen(str_arg);
            printf("%d\n", m);
            printf("%d\n", n);
        }
        int main(void){
            char str[]="Hello";
            Func(str);
        }
        输出结果为：

    答案：
        4，5
        1. str为定义在main函数中的数组。
        2. 数组作为参数传递给函数会退化为指针。
        3. sizeof(指针变量) = 指针变量大小，strlen(指针变量) = 指针所指向的字符串长（遇'\0'停止）。

Q7 :

    题目：
        给定一个字符串,求出其最长的重复子串。

    答案：

---

### 模拟2

Q1 :

    题目：
        Internet物理地址和IP地址转换采用什么协议？

    答案：
        1. MAC地址 -> IP地址：ARP协议。
        2. IP地址 -> MAC地址：RARP协议。

[Q2](http://blog.csdn.net/lanchengxiaoxiao/article/details/7880276) :

    题目：
        static有什么用途？

    答案：
        1. 修饰变量：
            静态局部变量：只定义一次，程序运行期间一直存在，作用于局限于定义的函数内。多线程中需要加锁保护。
            静态全局变量：程序运行期间一直存在，作用域为定义它的源文件。
        2. 修饰函数：
            一个被声明为静态的函数只可被这一模块内的其它函数调用。

Q3 :

    题目：
        引用与指针有什么区别？

    答案：
        1. 指针是个实体，指针的内容是变量地址。引用只是变量别名。
        2. 指针可以指向新的变量地址。引用只能在定义时被初始化一次，之后不可变。
        3. 指针可以为空。引用不能为空。
        4. 指针可以用const修饰，引用不能用const修饰。
        5. 获取变量值指针需要解引用。引用不需要解引用。
        6. 指针变量需要分配实际内存空间。引用不需要分配内存空间，本身不是变量。
        7. 指针的sizeof得到的是指针变量的大小。引用得到的是实际变量的大小。
        8. 指针变量++是地址值的增加。引用的++是实际变量值得增加。

Q4 :

    题目：
        全局变量和局部变量在内存中是否有区别？如果有，是什么区别？

    答案：
        1. 作用域：
            全局变量：具有全局作用域，只需要定义在一个源文件中就可以在所有源文件中使用。不包含变量定义的文件引用时要用extern声明。
            局部变量：具有局部作用域，只在函数运行期间存在，函数结束后就被销毁。
        2. 生存周期：
            全局变量：定义在静态区，与静态变量存储在一起，伴随程序整个生命周期。
            局部变量：定义在栈上，函数结束后释放。

Q5 :

    题目：
        什么是平衡二叉树？

    答案：
        1. 空树或者左右两棵子树高度差绝对值小于1，且子树递归满足此定义。
        2. 最小平衡二叉树节点公式：F(n) = F(n - 1) + F(n - 2) + 1。

Q6 :

    题目：
        堆栈溢出一般是由什么原因导致的？

    答案：
        1. 循环的递归调用（每次递归都需要压栈）。
        2. 大数据结构的局部变量。

Q7 :

    题目：
        什么函数不能声明为虚函数？

    答案：
        1. 构造函数。虚函数主要针对对象而言，而构造函数是在对象创建之前。
        2. 内联函数。不能再运行中动态确定其位置。
        3. 静态成员函数。全局通用，不受限于具体对象。

Q8 :

    题目：
       写出floatx与“零值”比较的if语句。

    答案：
        1. if (fabs(x) < 0.00001f)

Q9 :

    题目：
        不能做switch()的参数类型是？

    答案：
        1. 只能是char，int，enum。
        2. 不能是bool，long，string，float，double。

Q10 :

    题目：
        用户输入M、N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。

    答案：

---

### 模拟3

Q1 :

    题目：
        写出下列代码的输出内容：
        int inc(int a){
            return(++a);
        }
        int multi(int*a, int*b, int*c){
            return(*c = *a**b);
        }
        typedef int(FUNC1)(int in);
        typedef int(FUNC2)(int*, int*, int*);
        void show(FUNC2 fun, int arg1, int*arg2){
            FUNC1 *p = &inc;
            int temp = p(arg1);
            fun(&temp, &arg1, arg2);
            printf("%d\n", *arg2);
        }
        int main(){
            int a;
            show(multi, 10, &a);
            return 0;
        }

    答案：
        110

Q2 :

    题目：
        如何引用一个已经定义过的全局变量?

    答案：
        1. 用extern重新声明已经在别的模块中定义的全局变量，如果写错变量名将会在链接阶段报错。
        2. 引用定义了该全局变量的头文件，如果拼写错误会在编译阶段报错。

Q3 :

    题目：
        语句for(; 1; )有什么问题？它是什么意思？

    答案：
        1. 一直循环执行。
        2. 此处如果中间是0，则一次不执行。

Q4 :

    题目：
        static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？

    答案：
        1. static全局变量仅能在定义的源文件中使用，全局变量可以在所有源文件中使用。
        2. static局部变量定义于静态区，生命周期为程序整个运行阶段，多次调用函数只定义一次。局部变量定义于栈，调用函数退出即销毁，多次调用多次分配。
        3. static函数只能在定义的源文件中使用。普通函数可以在头文件中声明，包含该头文件的源文件均可调用该函数。

Q5 :

    题目：
        请找出下面代码中的所有错误：
        #include<string.h>
        int main(){
            char*src = "hello,world";
            char* dest = NULL;
            int len = strlen(src);
            dest = (char*)malloc(len); (1)
            char* d = dest;
            char* s = src[len]; (2)
            while(len-- != 0) (3)
                d++ = s--; (4)
            printf("%s", dest);
            return 0;
        }

    答案：
        1. 分配的空间要为len + 1，用于存放'\0'。
        2. s = &src[len]这里是取地址。
        3. 改为while(len-- >= 0)。
        4. 改为*d++ = *s--。

Q6 :

    题目：
        搜索引擎的日志要记录所有查询串，有一千万条查询，不重复的不超过三百万，要统计最热门的10条查询。
        条件：串内存<1G，字符串长0-255。
        给出主要解决思路，算法及其复杂度分析。

    答案：
        1. 面对的问题有：
            (1)1G内存不够一次性装入所有数据？
            (2)如何去统计每个记录出现次数？
            (3)如何快速得到前十的记录？
        2. 解决方式：
            (1)255约2^8，一百万约2^20，即一百万记录约256MB，一千万约2.6GB。分多次处理。
            (2)利用hash统计，定义map，key为string类型日志，value为日志出现次数。
            (3)利用大根堆，取top 10，复杂度O(nlogn)。
        3. 新问题：
            如何划分数据？如何归并结果？
        4. 方案：
            (1)哈希表常驻内存，大小(255 +4) * 3 * 1000000，约800MB。
            (2)分13（200MB * 13 = 2.6GB）次调入日志数据，每次取200MB数据进行hash。
---

### 模拟4

Q1 :

    题目：
        考虑函数原型void hello(int a, int b = 7, char* pszC = "*")，下面的函数调用中，属于不合法调用的是：
        A. hello(5);
        B. hello(5, 8);
        C. hello(6, "#");
        D. hello(0, 0, "#");

    答案：
        C 

    解答：
        1. 参数从左往右依次赋值。
        2. 有默认值时，调用函数参数缺失时使用默认值。
        3. 参数中字符串会转为指向字符串的指针。

Q2 :

    题目：
        下列程序的运行结果为：
        #include<iostream>
        using namespace std;
        void main(){
            int a = 2;
            int b = ++a;
            cout << a / 6 << endl;
        }
        A. 0.5
        B. 0
        C. 0.7
        D. 0.666666

    答案：
        B

    解答：
        1. 这里的6仅仅是整型数，所以和a进行操作时不存在精度提升。
        2. a的值进过++a之后变为3，3 / 6 = 0。

Q3 :

    题目：
        #define ADD(x, y) x + y
        int m = 3;
        m += m * ADD(m, m);
        m的值为多少：
        A. 15
        B. 12
        C. 18
        D. 58

    答案：
        A

    解答：
        1. 原式 = m + [m * m + m] = 3 + [3 * 3 + 3] = 15
        2. 有+=时先算右边部分。
        3. 除非出现++m，否则在同一条语句内，变量值不会改变。

Q4 :

    题目：
        下面哪种情况下，B不能隐式转换为A?
        A. class B:public A{}
        B. class A:public B{}
        C. class B{operator A();}
        D. class A{A(const B&);}

    答案：
        B

    解答：
        1. 派生类 -> 基类，向上级转换是隐式的，只需要丢弃多余的部分即可，反之基类没有多余的空间存放B独有的变量。
        2. C是隐式类型转换操作符。
        3. D是拷贝构造函数进行隐式转化。
Q5 :

    题目：
        假设你在编写一个使用多线程技术的程序，当程序中止运行时，需要怎样一个机制来安全有效的中止所有的线程?

    答案：
        1. 主线程检查是否有子线程在运行。
        2. 若有则发起线程退出操作(quit)。
        3. wait线程完全停止，delete线程对象。
        4. 等待所有线程结束(发出finish信号)，才退出程序。

Q6 :

    题目：
        从程序健壮性进行分析，下面的FillUserInfo函数和main函数分别存在什么问题?
        #define MAX_NAME_LEN 20
        struct USERINFO{
            int nAge;
            char szName[MAX_NAME_LEN];
        };
        void FillUserInfo(USERINFO *parUserInfo){
            stu::cout << "请输入用户的个数:";
            int nCount = 0;
            std::cin >> nCount;
            for (int i = 0; i < nCount; i++){
                std::cout << "请输入年龄:";
                std::cin >> parUserInfo[i]->nAge;
                std::string strName;
                std::cout << "请输入姓名:";
                std::cin >> strName;
                strcpy(parUserInfo[i].szName, strName.c_str());
            }
        }
        int main(int argc, char *argv[]){
            USERINFO arUserInfos[100] = {0};
            FillUserInfo(arUserInfos);
            printf("The first name is:");
            printf(arUserInfos[0].szName);
            printf("\n");
            return 0;
        }

    答案：

---

### 模拟5

Q1 :

    题目：
        设某种二叉树有如下特点：每个结点要么是叶子结点，要么有2棵子树。假如一棵这样的二叉树中有m（m > 0）个叶子结点，那么该二叉树上的结点总数为：
        A. 2m + 1
        B. 2m - 1
        C. 2(m - 1)
        D. 2m

    答案：
        B

    解答：
        1. 关键考点： 
            (1)叶子节点数 = 度为2的节点数 + 1
            (2)树的度 = 所有节点度的和
            (3)树的节点数 = 树的度 + 1
        2. 计算步骤：
            (1)度为2的节点数 = m - 1
            (2)树的度 = m * 0 + 0 * 0 + (m - 1) * 2 = 2m - 2
            (3)树的节点数 = (2m - 2) + 1 = 2m - 1
Q2 :

    题目：
        中断响应时间是指：
        A. 从中断处理开始到中断处理结束所用的时间
        B. 从发出中断请求到中断处理结束所用的时间
        C. 从发出中断请求到进入中断处理所用的时间
        D. 从中断处理结束到再次中断请求的时间

    答案：
        C

    解答：
        见答案。

Q3 :

    题目：
        试写出“背包题目”的非递归解法。

    答案：

---

### 模拟6

Q1 :

    题目：
        下推自动识别机的语言是：
        A. 0型语言
        B. 1型语言
        C. 2型语言
        D. 3型语言

    答案：
        C 

    解答：
        1. 0型文法产生的语言称为0型语言。
        2. 1型文法产生的语言称为1型语言，也称作上下文有关语言。
        3. 2型文法产生的语言称为2型语言，也称作上下文无关语言。
        4. 3型文法产生的语言称为3型语言，也称作正规语言。

Q2 :

    题目：
        浏览器访问某页面，HTTP协议返回状态码为403时表示：
        A. 找不到该页面
        B. 禁止访问
        C. 内部服务器访问
        D. 服务器繁忙

    答案：
        B 

    解答：
        1. 100-199，指定客服端相应的某些动作
        2. 200-299，表示请求成功
        3. 300-399，用于已经移动的文件并且包含在定位头信息中指定
        4. 400-499，客服端错误
        5. 500-599，服务端错误

Q3 :

    题目：
        递归函数最终会结束，那么这个函数一定：
        A. 使用了局部变量
        B. 有一个分支不调用自身
        C. 使用了全局变量或者使用了一个或多个参数
        D. 没有循环调用

    答案：
        B

    解答：
        1. 分支不调用自身即函数出口。

Q4 :

    题目：
        编译过程中，语法分析器的任务是：
        A. 分析单词是怎样构成的
        B. 分析单词串是如何构成语言和说明的
        C. 分析语句和说明是如何构成程序的
        D. 分析程序的结构

    答案：
        B, C, D

    解答：
        1. 词法分析：词法分析是编译过程的第一个阶段。这个阶段的任务是从左到右的读取每个字符，然后根据构词规则识别单词。词法分析可以用lex等工具自动生成。
        2. 语法分析：语法分析是编译过程的一个逻辑阶段。语法分析在词法分析的基础上，将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等。语法分析程序判断程序在结构上是否正确。
        3. 语义分析：属于逻辑阶段。对源程序进行上下文有关性质的审查，类型检查。如赋值语句左右端类型匹配问题。

Q5 :

    题目：
        进程进入等待状态有哪几种方式:
        A. CPU调度给优先级更高的线程
        B. 阻塞的线程获得资源或者信号
        C. 在时间片轮转的情况下，如果时间片到了
        D. 获得spinlock未果

    答案：
        D

    解答：
        1. A和C均是由从运行态转为就绪状态。
        2. B是由阻塞状态转为就绪状态。
        3. 自旋锁（spinlock）是一种保护临界区最常见的技术。在同一时刻只能有一个进程获得自旋锁，其他企图获得自旋锁的任何进程将一直进行尝试。
Q6 :

    题目：
        同一进程下的线程可以共享以下：
        A. stack
        B. data section
        C. register set
        D. file fd

    答案：
        B, D

    解答：
        1. 线程共享的内容包括：
            进程代码段
            进程的公有数据
            进程打开的文件描述符
            信号的处理器
            进程的当前目录
            进程用户ID与进程组ID
        2. 线程独有的内容包括：
            线程ID
            寄存器组的值
            线程的堆栈
            错误返回码
            线程的信号屏蔽码

Q7 :

    题目：
        设计模式中，属于结构型模式的有哪些：
        A. 状态模式
        B. 装饰模式
        C. 代理模式
        D. 观察者模式

    答案：
        B, C

    解答：
        1. 创建型模式：
            单例模式
            抽象工厂模式
            建造者模式
            工厂模式
            原型模式
        2. 结构型模式：
            适配器模式
            桥接模式
            装饰模式
            组合模式
            外观模式
            享元模式
            代理模式
        3. 行为型模式：
            模版方法模式
            命令模式
            迭代器模式
            观察者模式
            中介者模式
            备忘录模式
            解释器模式
            状态模式
            策略模式
            职责链模式
            访问者模式

Q8 :

    题目：
        Unix系统中，哪些可以用于进程间的通信：
        A. Socket
        B. 共享内存
        C. 消息队列
        D. 信号量

    答案：
        A, B，C，D

    解答：
        1. Linux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字。
        2. Linux线程间通信：互斥量、信号量、条件变量。
        3. Windows进程间通信：管道、消息队列、共享内存、信号量、套接字。
        3. Windows线程间通信：互斥量、信号量、临界区、事件。

Q9 :

    题目：
        设t是给定的一棵二叉树，下面的递归程序count(t)用于求得：
        typedef struct node{
            int data;
            struct node *lchild, *rchild;
        }node;
        int N2, NL, NR, N0;
        void count(node *t){
            if (t->lchild != NULL)
                if (t->rchild != NULL) N2++;
                else NL++;
            else if(t->rchild != NULL)
                NR++;
            else N0++;
            if(t->lchild != NULL)
                count(t->lchild);
            if(t->rchild != NULL)
                count(t->rchild);
        }
    答案：

Q10 :

    题目：
        请设计一个排队系统，能够让每个进入队伍的用户都能看到自己在队列中所处的位置和变化，队伍可能随时有人加入和退出；当有人退出影响到用户的位置排名时需要及时反馈到用户。

    答案：

Q11 :

    题目：
        A、B两个整数集合，设计一个算法求他们的交集，尽可能的高效。

    答案：

---

### 模拟6

Q1 : 

    题目：
        如何减少换页错误：
        A. 进程倾向于占用CPU
        B. 访问局部性（locality of reference）满足进程要求
        C. 进程倾向于占用I/O
        D. 使用基于最短剩余时间（shortest remaining time）的调度机制

    答案：
        B

    解答：
        1. 换页错误又称缺页错误，当一个程序试图访问没有映射到物理内存的地方时，就会出现缺页错误。
        2. 减少缺页发生的方法：
            增加作业分配的内存块数。
            增加页面大小。
            页面替换算法。
            程序满足局部性原理。

Q2 : 

    题目：
        有1000亿条记录，每条记录由url,ip,时间组成，设计一个系统能够快速查询以下内容。
        1. 给定url和时间段（精确到分钟）统计url的访问次数。
        2. 给定ip和时间段（精确到分钟）统计ip的访问次数。

    答案：

Q3 : 

    题目：

        给定一个包含了用户query的日志文件，对于输入的任意一个字符串s，输出以s为前缀的在日志中出现频率最高的前10条query。
        至少有26台机器，每个机器存储以26个字母开头的query日志文件（机器1以a字母开头的，机器2以b字母开头……）。
        各机器维护一张哈希表，每条query在哈希表中存放其地址（哈希地址为链式的），并对其进行排序，按频率由高到低进行排序。
        当用户进行搜索时，可以很快定位到某台机器，并根据哈希表，返回出现频率最高的前10条query。

        提示：
        1. 可以预处理日志。
        2. 假设query超过10亿条，每个query不超过50字节。
        3. 考虑在大查询量的情况下如何实现分布式服务。

    答案：


---

### 模拟7

Q1 :

    题目：
        下列哪些http方法对于服务端和用户端一定是安全的？
        A. GET
        B. HEAD
        C. TRACE
        D. OPTION
        E. POST

    答案：
        C 

    解答：

Q2 :

    题目：
        一个系统，提供多个http协议的接口，返回的结果Y有json格式和jsonp格式。Json的格式为{"code":100,"msg":"aaa"}，为了保证该协议变更之后更好的应用到多个接口，为了保证修改协议不影响到原先逻辑的代码，以下哪些设计模式是需要的?协议的变更指的是日后可能返回xml格式，或者是根据需求统一对返回的消息进行过滤。
        A. Aadapter
        B. factory method
        C. proxy
        D. decorator
        E. composite

    答案：
        A, B, D

    解答：

---

### 模拟8

Q1 :

    题目：
        在数据库系统中，产生不一致的根本原因是：
        A. 数据存储量太大
        B. 没有严格保护数据
        C. 未对数据进行完整性控制
        D. .数据冗余

    答案：


    解答：

Q2 :

    题目：
        请问下面的程序一共输出多少个“-”？
        int main(void){
            int i;
            for(i = 0; i < 2; i++){
                fork();
                printf("-");
            }
            return 0;
        }
        A. 2
        B. 4
        C. 6
        D. 8

    答案：


    解答：

Q3 :

    题目：
        请问下面的程序一共输出多少个“-”？为什么？
        #include <stdio.h>
        #include <sys/types.h>
        #include <unistd.h> 
        int main(void){
            int i;
            for (i = 0; i < 2; i++){
                fork();
                printf("-\n");
            }
            return 0;
        }
        A. 4
        B. 5
        C. 6
        D. 8

    答案：


    解答：

Q4 :

    题目：

        A.
        B.
        C.
        D.

    答案：


    解答：

Q5 :

    题目：

        A.
        B.
        C.
        D.

    答案：


    解答：
---

## <span id = "n">NetEase</span>

---

## <span id = "360">360</span>
